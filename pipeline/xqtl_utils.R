# THIS FILE IS AUTOMATICALLY GENERATED
# DO NOT EDIT THIS FILE
library(harmonicmeanp)
library(Rfast)
library(plink2R)
library(susieR)
library(readr)
library(glmnet)
library(mr.ash.alpha)

read_pvar <- function(pgen){
  pvarf <- paste0(tools::file_path_sans_ext(pgen), ".pvar")
  pvardt <- data.table::fread(pvarf, skip = "#CHROM")
  pvardt <- dplyr::rename(pvardt, "chrom" = "#CHROM", "pos" = "POS",
                "alt" = "ALT", "ref" = "REF", "id" = "ID")
  pvardt <- pvardt[, c("chrom", "id", "pos", "alt", "ref")]
  return(pvardt)
}

read_bim <- function(bed) {
  bimf <- paste0(tools::file_path_sans_ext(bed), ".bim")
  bim <- data.table::fread(bimf)
  colnames(bim) <- c("chrom", "id", "gpos", "pos", "a1", "a0")
  return(bim)
}

read_psam <- function(pgen) {
  psamf <- paste0(tools::file_path_sans_ext(pgen), ".psam")
  psam = data.table::fread(psamf, header=T)
  colnames(psam)[1:2] = c("FID", "IID")
  return(psam)
}

read_fam <- function(bed) {
    famf <- paste0(tools::file_path_sans_ext(bed), ".fam")
    return(data.table::fread(famf, header = F))
}

open_pgen <- function(pgenf){
    return(pgenlibr::NewPgen(pgenf))
} 

open_bed <- function(bed){
    raw_s_ct <- nrow(read_fam(bed))
    return(pgenlibr::NewPgen(bed, raw_sample_ct = raw_s_ct))
}

read_pgen <- function(pgen, variantidx = NULL, meanimpute = F ) {
  if (is.null(variantidx)){
    variantidx <- 1: pgenlibr::GetVariantCt(pgen)}

  pgenlibr::ReadList(pgen,
                     variant_subset = variantidx,
                     meanimpute = meanimpute)
}

compute_maf <- function(geno){
  f <- mean(geno,na.rm = TRUE)/2
  return(min(f, 1-f))
}

compute_missing <- function(geno){
  miss <- sum(is.na(geno))/length(geno)
  return(miss)
}

mean_impute <- function(geno){
  f <- apply(geno, 2, function(x) mean(x,na.rm = TRUE))
  for (i in 1:length(f)) geno[,i][which(is.na(geno[,i]))] <- f[i]
  return(geno)
}

is_zero_variance <- function(x) {
  if (length(unique(x))==1) return(T)
  else return(F)
}

filter_X <- function(X, missing_rate_thresh, maf_thresh) {
    rm_col <- which(apply(X, 2, compute_missing) > missing_rate_thresh)
    if (length(rm_col)) X <- X[, -rm_col]
    rm_col <- which(apply(X, 2, compute_maf) <= maf_thresh)
    if (length(rm_col)) X <- X[, -rm_col]
    rm_col <- which(apply(X, 2, is_zero_variance))
    if (length(rm_col)) X <- X[, -rm_col]
    return(mean_impute(X))
}

thisFile <- function() {
  cmdArgs <- commandArgs(trailingOnly = FALSE)
  needle  <- "--file="
  match   <- grep(needle,cmdArgs)
  if (length(match) > 0) {
    path <- cmdArgs[match]
    path <- gsub("\\~\\+\\~", " ", path)
    return(normalizePath(sub(needle, "", path)))
  } else {
    return(sys.frames()[[1]]$ofile)
  }
}

load_script <- function() {
  fileName <- thisFile()
  return(ifelse(!is.null(fileName) && file.exists(fileName),
                readChar(fileName,file.info(fileName)$size),""))
}
             
compute_cov_flash <- function(Y, error_cache = NULL){
    covar <- diag(ncol(Y))
    tryCatch({
    fl <- flashier::flash(Y, var.type = 2, prior.family = c(flashier::prior.normal(), flashier::prior.normal.scale.mix()), backfit = TRUE, verbose.lvl=0)
    if(fl$n.factors==0){
      covar <- diag(fl$residuals.sd^2)
    } else {
      fsd <- sapply(fl$fitted.g[[1]], '[[', "sd")
      covar <- diag(fl$residuals.sd^2) + crossprod(t(fl$flash.fit$EF[[2]]) * fsd)
    }
    if (nrow(covar) == 0) {
      covar <- diag(ncol(Y))
      stop("Computed covariance matrix has zero rows")
    }
    }, error = function(e) {
      if (!is.null(error_cache)) {
        saveRDS(list(data=Y, message=warning(e)), error_cache)
        warning("FLASH failed. Using Identity matrix instead.")
        warning(e)
      } else {
        stop(e)
      }
    })
    s <- apply(Y, 2, sd, na.rm=T)
    if (length(s)>1) s = diag(s)
    else s = matrix(s,1,1)
    covar <- s%*%cov2cor(covar)%*%s
    return(covar)
}

compute_cov_diag <- function(Y){
    covar <- diag(apply(Y, 2, var, na.rm=T))
    return(covar)
}

tabix_region <- function(file, region){
    fread(cmd = paste0("tabix -h ", file, " ", region))%>%as_tibble() 
}

load_regional_association_data <- function(genotype, # PLINK file
                                           phenotype, # a vector of phenotype file names 
                                           covariate, # a vector of covariate file names corresponding to the phenotype file vector
                                           region, # a string of chr:start-end
                                           conditions, # a vector of strings
                                           maf_cutoff = 0,
                                           mac_cutoff = 0,
                                           imiss_cutoff = 0,
                                           y_as_matrix = FALSE,
                                           keep_indel = TRUE) {
    geno = read_plink(genotype)
    rownames(geno$bed) = read.table(text = rownames(geno$bed), sep= ":")$V2
    if (!keep_indel){
    geno_bim = geno$bim%>%rename("chrom" = "V1","variant_id" = "V2","alt" = "V5","ref"="V6")%>%mutate(indel = ifelse(grepl("[^ATCG]",alt)=="TRUE"|grepl("[^ATCG]",ref)=="TRUE"|nchar(alt)!=nchar(ref),1, 0))
    geno_bed = geno$bed[,geno_bim$indel==0]}
    else {
    geno_bed = geno$bed
    }
    data_list = tibble(covariate_path = covariate, phenotype_path =phenotype) %>%
        mutate(covar = map(covariate_path, ~read_delim(.x,"\t")%>%select(-1)%>%na.omit%>%t()),
        Y = map2(phenotype_path,covar, ~{
          y_data <- tabix_region(.x, region)%>%select(-4)%>%select(rownames(.y))%>%t()%>%as.matrix
          return(y_data)
          }),
        Y = map(Y, ~.x%>%na.omit),    # remove na where Y raw data has na which block regression
        dropped_sample = map2(covar, Y , ~rownames(.x)[!rownames(.x) %in% rownames(.y)]),
        covar = map2(covar, Y , ~.x[intersect(.x%>%rownames,rownames(.y)),]), # remove the dropped samples from Y
        X_data = map(covar,~ filter_X( geno_bed[intersect(rownames(.x),rownames(geno_bed)),], imiss_cutoff, max(maf_cutoff, mac_cutoff/(2*length(intersect(rownames(.x),rownames(geno_bed))) ) ))   ))
              
    data_list = data_list%>%mutate(Y_resid_mean = map2(Y,covar,~.lm.fit(x = cbind(1,.y), y = .x)$residuals%>%mean),
                               Y_resid_sd = map2(Y,covar,~.lm.fit(x = cbind(1,.y), y = .x)$residuals%>%sd),
                               Y_resid = map2(Y,covar,~.lm.fit(x = cbind(1,.y), y = .x)$residuals%>%scale%>%t%>%as_tibble)) ## T so that it can be unnest
    if(y_as_matrix) {
        Y_resid = data_list%>%select(Y_resid)%>%tidyr::unnest(Y_resid)%>%t%>%as.matrix
        colnames(Y_resid) = conditions
        print(paste("Dimension of Y matrix:", nrow(Y_resid), ncol(Y_resid)))
    } else {
        Y_resid = map(data_list$Y_resid,~.x%>%t) # Transpose back 
        names(Y_resid) = conditions
    }
    all_samples = map(data_list$covar, ~rownames(.x))%>%unlist%>%unique()
    maf_cutoff = max(maf_cutoff,mac_cutoff/(2*length(all_samples)))
    X = filter_X(geno_bed[all_samples,], imiss_cutoff, maf_cutoff) ## Filter X for mvSuSiE
    maf_list = lapply(data_list$X_data, function(x) apply(x, 2, compute_maf))
    print(paste0("Dimension of input genotype data is row:", nrow(X), " column: ", ncol(X) ))
    X_list = data_list%>%mutate(X_resid_mean= map2(X_data,covar,~.lm.fit(x = cbind(1,.y), y = .x)$residuals%>%data.frame()%>%apply(.,2,mean)),
                               X_resid_sd= map2(X_data,covar,~.lm.fit(x = cbind(1,.y), y = .x)$residuals%>%data.frame()%>%apply(.,2,sd)),
                               X_resid = map2(X_data,covar,~.lm.fit(x = cbind(1,.y), y = .x)$residuals%>%scale))%>%select(X_resid_mean,X_resid_sd,X_resid)
    return (list(
            residual_Y_scaled = Y_resid,
            residual_X_scaled = X_list$X_resid,
            residual_Y_sd = data_list$Y_resid_sd,
            residual_X_sd = X_list$X_resid_sd,
            dropped_sample = data_list$dropped_sample,
            covar = data_list$covar,
            Y = data_list$Y,
            X = X,
            X_data = data_list$X_data,
            maf = maf_list
            ))
}

load_regional_finemapping_data <- function(...) {
  dat <- load_regional_association_data(...)
  return (list(
          residual_Y_scaled = dat$residual_Y_scaled,
          residual_X_scaled = dat$residual_X_scaled,
          residual_Y_sd = dat$residual_Y_sd,
          residual_X_sd = dat$residual_X_sd,
          X = dat$X,
          dropped_sample = dat$dropped_sample,
          maf = dat$maf
          ))
}

load_regional_quantile_data <- function(...) {
  dat <- load_regional_association_data(...)
  return (list(
          Y = dat$Y,
          X_data = dat$X_data,
          covar = dat$covar,
          dropped_sample = dat$dropped_sample,
          maf = dat$maf
          ))
}

post_process_susie <- function(fobj, fdat, r, secondary_coverage = 0.7,signal_cutoff = 0.1) {
    get_cs_index <- function(snps_idx, susie_cs) {
        idx <- tryCatch(
            which(
                pmap(list(a = susie_cs), function(a) snps_idx %in% a) %>% unlist()
            ),
            error = function(e) NA_integer_
        )
        if(length(idx) == 0) return(NA_integer_)
        return(idx)
    }
    eff_idx = which(fobj$V>0)
    if (length(eff_idx)>0) {
        fobj$sets_secondary = susie_get_cs(fobj, fdat$residual_X_scaled[[r]], coverage=secondary_coverage)
        fobj$analysis_script = load_script()
        fobj$cs_corr = get_cs_correlation(fobj, X=fdat$residual_X_scaled[[r]])
        fobj$cs_snps = gsub("_",":",names(fobj$pip[unlist(fobj$sets$cs)]))
        fobj$phenotype_name = colnames(fdat$residual_Y_scaled[[r]])
        fobj$dropped_samples = fdat$dropped_sample[[r]]
        fobj$sample_names = rownames(fdat$residual_Y_scaled[[r]])
        fobj$variant_names = gsub("_",":",names(fobj$pip))
        variants_index = c(which(fobj$pip >= signal_cutoff), unlist(fobj$sets$cs)) %>% unique %>% sort
        if (length(variants_index)==0) {
            variants_index = which.max(fobj$pip)
        }
        variants_index_secondary = c(which(fobj$pip >= signal_cutoff), unlist(fobj$sets_secondary$cs)) %>% unique %>% sort
        if (length(variants_index_secondary)==0) {
            variants_index_secondary = which.max(fobj$pip)
        }
        variants_merge = unique(c(variants_index, variants_index_secondary))%>%sort
        maf = fdat$maf[[r]][variants_merge]
        variants = gsub("_",":",names(fobj$pip)[variants_merge])
        pip = fobj$pip[variants_merge]
        cs_info_pri = map_int(variants_index, ~get_cs_index(.x, fobj$sets$cs))
        cs_info_sec = map_int(variants_index_secondary, ~get_cs_index(.x, fobj$sets_secondary$cs))
        cs_pri= ifelse(is.na(cs_info_pri), 0, str_replace(names(fobj$sets$cs)[cs_info_pri], "L", "") %>% as.numeric)
        cs_sec= ifelse(is.na(cs_info_sec), 0, str_replace(names(fobj$sets_secondary$cs)[cs_info_sec], "L", "") %>% as.numeric)
        cs_index_primary = cs_index_secondary = rep(NA, length(variants_merge))
        cs_index_primary[match(variants_index,variants_merge)]=cs_pri
        cs_index_secondary[match(variants_index_secondary,variants_merge)]=cs_sec
        Y_resid_sd = fdat$residual_Y_sd[[r]]
        X_resid_sd = fdat$residual_X_sd[[r]]
        univariate_res = univariate_regression(fdat$residual_X_scaled[[r]][, variants_index, drop=F], fdat$residual_Y_scaled[[r]])
        fobj$top_loci = data.frame(variants, maf, univariate_res$betahat, univariate_res$sebetahat, pip, cs_index_primary,cs_index_secondary)
        colnames(fobj$top_loci) = c("variant_id", "maf", "bhat", "sbhat", "pip", "cs_index_primary","cs_index_secondary")
        rownames(fobj$top_loci) = NULL
        fobj$alpha = fobj$alpha[eff_idx,,drop=F]
        fobj$mu = fobj$mu[eff_idx,,drop=F]
        fobj$mu2 = fobj$mu2[eff_idx,,drop=F]
        fobj$V = fobj$V[eff_idx]
        fobj$Xr = NULL
        fobj$fitted = NULL
        colnames(fobj$lbf_variable) = NULL
        colnames(fobj$alpha) = NULL
        colnames(fobj$mu) = NULL
        colnames(fobj$mu2) = NULL
        names(fobj$X_column_scale_factors) = NULL
        names(fobj$pip) = NULL
        class(fobj) = "list"
    } else {
        fobj = list(analysis_script = load_script(), pip = fobj$pip, variant_names = gsub("_",":",names(fobj$pip)))
        names(fobj$pip) = NULL
    }
    return(fobj)
}# FIXME: check that weights have the same length as z-scores
twas_z <- function(weights, z, R=NULL, X=NULL) {
    if (is.null(R)) {
        genetype_data_imputed <- apply(X, 2, function(x){
            pos <- which(is.na(x))
            if (length(pos) != 0){
                x[pos] <- mean(x,na.rm = TRUE)
                }
                return(x)
            })
        R <- cor(genetype_data_imputed) 
        colnames(R) <- rownames(R) <- colnames(genetype_data_imputed)
    }
    stat <- t(weights) %*% z
    denom <- t(weights) %*% R %*% weights
    zscore <- stat/sqrt(denom)
    pval <- pchisq( zscore * zscore, 1, lower.tail = FALSE)
    return(list(z=zscore, pval=pval))
}

susie_weights <- function(susie_fit) {
    coef.susie(susie_fit)[-1]
}

init_prior_sd <- function (X, y, n = 30) {
  res <- univariate_regression(X, y)
  smax <- 3*max(res$betahat)
  seq(0, smax, length.out = n)
}

glmnet_weights <- function(X, y, alpha=0.5) {
	eff.wgt = matrix(0, ncol=1, nrow=ncol(X))
	sds = apply(X, 2, sd)
	keep = sds != 0 & !is.na(sds)
	enet = cv.glmnet(x=X[,keep], y=y, alpha=alpha, nfold=5, intercept=T, standardize=F)
	eff.wgt[keep] = coef( enet , s = "lambda.min")[2:(sum(keep)+1)]
	return(eff.wgt)
}

mr_ash_weights <- function(X, y, init_prior_sd=TRUE, ...) {
    sa2 = NULL
    if (init_prior_sd) sa2 = init_prior_sd(X,y)^2
    fit.mr.ash = mr.ash(X, y, sa2=sa2, ...)
    predict(fit.mr.ash, type = "coefficients")[-1]
}

pval_acat <- function(pvals) {
    if (length(pvals) == 1) {
        return(pvals[0])
    }
    stat <- 0.00
    pval_min <- 1.00

    stat <- sum(qcauchy(pvals))
    pval_min <- min(pval_min, min(qcauchy(pvals)))

    return(pcauchy(stat/length(pvals), lower.tail = FALSE))
}

pval_hmp <- function(pvals) {
    pvalues <- unique(pvals)
	L <- length(pvalues)
	HMP <- L/sum(pvalues^-1)

	LOC_L1 <- 0.874367040387922
	SCALE <- 1.5707963267949

	return(pLandau(1/HMP, mu = log(L) + LOC_L1, sigma = SCALE, lower.tail = FALSE))
}

pval_global <- function(pvals, comb_method = "HMP", naive=FALSE) {
    min_pval <- min(pvals)
    n_total_tests <- pvals %>% unique() %>% length() # There should be one unique pval per tissue
    global_pval <- if (comb_method == "HMP") pval_HMP(pvals) else pval_ACAT(pvals) # pval vector
    naive_pval <- min(n_total_tests*min_pval, 1.0)
    return(if (naive) naive_pval else global_pval) # global_pval and naive_pval
}# heterogeneity:  calculate I2 statistics based on the Cochran's Q statistic
calc_I2 = function(Q, Est) {
    Q = Q[[1]]
    Est = length(unique(Est))
    I2 = if (Q > 1e-3) (Q - Est + 1)/Q else 0
    return(if (I2 < 0) 0 else I2)
}

fine_mr <- function(formatted_input, cpip_cutoff=0.5) {
output = formatted_input %>%
    mutate(
        bhat_x = bhat_x/sbhat_x,
        sbhat_x = 1) %>%
    group_by(X_ID, cs) %>%
    mutate(cpip = sum(pip)) %>%
    filter(cpip >= cpip_cutoff) %>% # Cumulative pip greater than a user defined cumulative pip threshold
    group_by(X_ID, cs) %>%
    mutate(
        beta_yx = bhat_y/bhat_x,
        se_yx = sqrt(
            (sbhat_y^2/bhat_x^2) + ((bhat_y^2*sbhat_x^2)/bhat_x^4)),
        composite_bhat = sum((beta_yx*pip)/cpip),
        composite_sbhat = sum((beta_yx^2 + se_yx^2)*pip/cpip)) %>%
    mutate(
        composite_sbhat = sqrt(composite_sbhat - composite_bhat^2),
        wv = composite_sbhat^-2) %>%
    ungroup() %>%
    group_by(X_ID) %>%
    mutate(
        meta_eff = sum(unique(wv) * unique(composite_bhat)),
        sum_w = sum(unique(wv)),
        se_meta_eff = sqrt(sum_w^-1),
        num_CS = length(unique(cs))) %>%
    mutate(
        num_IV = length(snp),
        meta_eff = meta_eff/sum_w,
        Q = sum(unique(wv)*(unique(composite_bhat) - unique(meta_eff))^2),
        I2 = calc_I2(Q, composite_bhat)) %>%
        ungroup() %>%
    distinct(X_ID, .keep_all = TRUE) %>%
    mutate(
        cpip = round(cpip, 3),
        composite_bhat = round(composite_bhat, 3),
        meta_eff = round(meta_eff, 3),
        se_meta_eff = round(se_meta_eff, 3),
        Q = round(Q, 3),
        I2 = round(I2, 3)) %>%
    select(X_ID, num_CS, num_IV, cpip, composite_bhat, composite_sbhat, meta_eff, se_meta_eff, Q, I2)
    return(output)
}